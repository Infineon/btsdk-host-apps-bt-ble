/*
 * Copyright 2016-2021, Cypress Semiconductor Corporation (an Infineon company) or
 * an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 *
 * This software, including source code, documentation and related
 * materials ("Software") is owned by Cypress Semiconductor Corporation
 * or one of its affiliates ("Cypress") and is protected by and subject to
 * worldwide patent protection (United States and foreign),
 * United States copyright laws and international treaty provisions.
 * Therefore, you may use this Software only as provided in the license
 * agreement accompanying the software package from which you
 * obtained this Software ("EULA").
 * If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 * non-transferable license to copy, modify, and compile the Software
 * source code solely for use in connection with Cypress's
 * integrated circuit products.  Any reproduction, modification, translation,
 * compilation, or representation of this Software except as specified
 * above is prohibited without the express written permission of Cypress.
 *
 * Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT, IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. Cypress
 * reserves the right to make changes to the Software without notice. Cypress
 * does not assume any liability arising out of the application or use of the
 * Software or any product or circuit described in the Software. Cypress does
 * not authorize its products for use in any products where a malfunction or
 * failure of the Cypress product may reasonably be expected to result in
 * significant property damage, injury or death ("High Risk Product"). By
 * including Cypress's product in a High Risk Product, the manufacturer
 * of such system or application assumes all risk of such use and in doing
 * so agrees to indemnify Cypress against all liability.
 */
/* Automatically generated nanopb constant definitions */
/* Generated by nanopb-0.3.9 at Wed Oct 31 16:42:06 2018. */

#include "rpc.pb.h"

/* @@protoc_insertion_point(includes) */
#if PB_PROTO_HEADER_VERSION != 30
#error Regenerate this file with the current version of nanopb generator.
#endif



const pb_field_t RPC_HEADER_fields[14] = {
    PB_FIELD(  1, UENUM   , SINGULAR, STATIC  , FIRST, RPC_HEADER, subsystem, subsystem, 0),
    PB_ONEOF_FIELD(function_code, 102, ENUM    , ONEOF, STATIC  , OTHER, RPC_HEADER, l2cap_function_code, subsystem, 0),
    PB_ONEOF_FIELD(function_code, 103, ENUM    , ONEOF, STATIC  , UNION, RPC_HEADER, btm_function_code, subsystem, 0),
    PB_ONEOF_FIELD(function_code, 104, ENUM    , ONEOF, STATIC  , UNION, RPC_HEADER, gatt_function_code, subsystem, 0),
    PB_ONEOF_FIELD(function_code, 105, ENUM    , ONEOF, STATIC  , UNION, RPC_HEADER, gap_function_code, subsystem, 0),
    PB_ONEOF_FIELD(function_code, 106, ENUM    , ONEOF, STATIC  , UNION, RPC_HEADER, rfc_function_code, subsystem, 0),
    PB_ONEOF_FIELD(function_code, 107, ENUM    , ONEOF, STATIC  , UNION, RPC_HEADER, btcom_function_code, subsystem, 0),
    PB_ONEOF_FIELD(function_code, 108, ENUM    , ONEOF, STATIC  , UNION, RPC_HEADER, spp_function_code, subsystem, 0),
    PB_ONEOF_FIELD(function_code, 109, ENUM    , ONEOF, STATIC  , UNION, RPC_HEADER, smp_function_code, subsystem, 0),
    PB_ONEOF_FIELD(function_code, 110, ENUM    , ONEOF, STATIC  , UNION, RPC_HEADER, avdt_function_code, subsystem, 0),
    PB_ONEOF_FIELD(function_code, 111, ENUM    , ONEOF, STATIC  , UNION, RPC_HEADER, avct_function_code, subsystem, 0),
    PB_ONEOF_FIELD(function_code, 112, ENUM    , ONEOF, STATIC  , UNION, RPC_HEADER, sdp_function_code, subsystem, 0),
    PB_ONEOF_FIELD(function_code, 113, ENUM    , ONEOF, STATIC  , UNION, RPC_HEADER, wiced_hci_gatt_db_function_code, subsystem, 0),
    PB_LAST_FIELD
};

const pb_field_t RPC_BytesResponse_fields[2] = {
    PB_FIELD(  1, BYTES   , SINGULAR, CALLBACK, FIRST, RPC_BytesResponse, res, res, 0),
    PB_LAST_FIELD
};

const pb_field_t RPC_Uint32Response_fields[2] = {
    PB_FIELD(  1, UINT32  , SINGULAR, STATIC  , FIRST, RPC_Uint32Response, res, res, 0),
    PB_LAST_FIELD
};

const pb_field_t RPC_BooleanResponse_fields[2] = {
    PB_FIELD(  1, BOOL    , SINGULAR, STATIC  , FIRST, RPC_BooleanResponse, res, res, 0),
    PB_LAST_FIELD
};

const pb_field_t RPC_BD_ADDR_fields[2] = {
    PB_FIELD(  1, BYTES   , SINGULAR, CALLBACK, FIRST, RPC_BD_ADDR, bd_addr, bd_addr, 0),
    PB_LAST_FIELD
};

const pb_field_t RPC_BD_NAME_fields[2] = {
    PB_FIELD(  1, BYTES   , SINGULAR, CALLBACK, FIRST, RPC_BD_NAME, bd_name, bd_name, 0),
    PB_LAST_FIELD
};

const pb_field_t RPC_DEV_CLASS_fields[2] = {
    PB_FIELD(  1, BYTES   , SINGULAR, CALLBACK, FIRST, RPC_DEV_CLASS, device_class, device_class, 0),
    PB_LAST_FIELD
};

const pb_field_t RPC_L2CAP_ERTM_INFO_fields[7] = {
    PB_FIELD(  1, UINT32  , SINGULAR, STATIC  , FIRST, RPC_L2CAP_ERTM_INFO, preferred_mode, preferred_mode, 0),
    PB_FIELD(  2, UINT32  , SINGULAR, STATIC  , OTHER, RPC_L2CAP_ERTM_INFO, allowed_modes, preferred_mode, 0),
    PB_FIELD(  3, UINT32  , SINGULAR, STATIC  , OTHER, RPC_L2CAP_ERTM_INFO, user_rx_pool_id, allowed_modes, 0),
    PB_FIELD(  4, UINT32  , SINGULAR, STATIC  , OTHER, RPC_L2CAP_ERTM_INFO, user_tx_pool_id, user_rx_pool_id, 0),
    PB_FIELD(  5, UINT32  , SINGULAR, STATIC  , OTHER, RPC_L2CAP_ERTM_INFO, fcr_rx_pool_id, user_tx_pool_id, 0),
    PB_FIELD(  6, UINT32  , SINGULAR, STATIC  , OTHER, RPC_L2CAP_ERTM_INFO, fcr_tx_pool_id, fcr_rx_pool_id, 0),
    PB_LAST_FIELD
};

const pb_field_t RPC_UUID_128_fields[2] = {
    PB_FIELD(  1, BYTES   , SINGULAR, CALLBACK, FIRST, RPC_UUID_128, uuid, uuid, 0),
    PB_LAST_FIELD
};

const pb_field_t RPC_BT_UUID_fields[5] = {
    PB_FIELD(  5, INT32   , SINGULAR, STATIC  , FIRST, RPC_BT_UUID, len, len, 0),
    PB_ONEOF_FIELD(uu,   6, UINT32  , ONEOF, STATIC  , OTHER, RPC_BT_UUID, uuid16, len, 0),
    PB_ONEOF_FIELD(uu,   7, UINT32  , ONEOF, STATIC  , UNION, RPC_BT_UUID, uuid32, len, 0),
    PB_ONEOF_FIELD(uu,   8, MESSAGE , ONEOF, STATIC  , UNION, RPC_BT_UUID, uuid128, len, &RPC_UUID_128_fields),
    PB_LAST_FIELD
};



























/* Check that field information fits in pb_field_t */
#if !defined(PB_FIELD_32BIT)
/* If you get an error here, it means that you need to define PB_FIELD_32BIT
 * compile-time option. You can do that in pb.h or on compiler command line.
 *
 * The reason you need to do this is that some of your messages contain tag
 * numbers or field sizes that are larger than what can fit in 8 or 16 bit
 * field descriptors.
 */
PB_STATIC_ASSERT((pb_membersize(RPC_BT_UUID, uu.uuid128) < 65536), YOU_MUST_DEFINE_PB_FIELD_32BIT_FOR_MESSAGES_RPC_HEADER_RPC_BytesResponse_RPC_Uint32Response_RPC_BooleanResponse_RPC_BD_ADDR_RPC_BD_NAME_RPC_DEV_CLASS_RPC_L2CAP_ERTM_INFO_RPC_UUID_128_RPC_BT_UUID)
#endif

#if !defined(PB_FIELD_16BIT) && !defined(PB_FIELD_32BIT)
/* If you get an error here, it means that you need to define PB_FIELD_16BIT
 * compile-time option. You can do that in pb.h or on compiler command line.
 *
 * The reason you need to do this is that some of your messages contain tag
 * numbers or field sizes that are larger than what can fit in the default
 * 8 bit descriptors.
 */
PB_STATIC_ASSERT((pb_membersize(RPC_BT_UUID, uu.uuid128) < 256), YOU_MUST_DEFINE_PB_FIELD_16BIT_FOR_MESSAGES_RPC_HEADER_RPC_BytesResponse_RPC_Uint32Response_RPC_BooleanResponse_RPC_BD_ADDR_RPC_BD_NAME_RPC_DEV_CLASS_RPC_L2CAP_ERTM_INFO_RPC_UUID_128_RPC_BT_UUID)
#endif


/* @@protoc_insertion_point(eof) */
